# Example java.util.logging configuration for Kachi Cache
#
# To use this configuration:
#   java -Djava.util.logging.config.file=logging.properties YourApp
#
# Or programmatically:
#   System.setProperty("java.util.logging.config.file", "logging.properties");
#   LogManager.getLogManager().readConfiguration();

# Default logging level for all loggers
.level=INFO

# Console handler configuration
handlers=java.util.logging.ConsoleHandler
java.util.logging.ConsoleHandler.level=ALL
java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter

# Format: [level] timestamp - logger - message
java.util.logging.SimpleFormatter.format=[%1$tF %1$tT] [%4$-7s] %2$s - %5$s %6$s%n

# ============================================================================
# Kachi Cache Logging Configuration
# ============================================================================

# Main Kachi cache logger
# Logger name: com.github.rudygunawan.kachi.Cache
#
# Available log levels (from most to least verbose):
#   ALL     - All messages
#   FINEST  - Very detailed debugging (not currently used)
#   FINER   - Detailed entry operations (not currently used)
#   FINE    - Cache operations (evictions, refreshes)
#   CONFIG  - Configuration messages (not currently used)
#   INFO    - Informational messages (not currently used)
#   WARNING - Errors in custom policies/listeners (operations continue)
#   SEVERE  - Critical errors (not currently used)
#   OFF     - No logging

# ====================
# Configuration Options
# ====================

# Option 1: ERROR ONLY (production default - recommended)
# Only log errors in custom policies/listeners
com.github.rudygunawan.kachi.Cache.level=WARNING

# Option 2: INFO (normal production)
# Currently same as WARNING since no INFO messages are logged
# com.github.rudygunawan.kachi.Cache.level=INFO

# Option 3: DEBUG (troubleshooting)
# Logs evictions and background refreshes
# com.github.rudygunawan.kachi.Cache.level=FINE

# Option 4: SILENT (no logging)
# com.github.rudygunawan.kachi.Cache.level=OFF

# ====================
# What Gets Logged at Each Level
# ====================
#
# WARNING (errors that don't stop cache operations):
#   - Exceptions in custom Expiry policy (falls back to default TTL)
#   - Exceptions in custom RefreshPolicy (falls back to fixed interval)
#   - Exceptions in RemovalListener callbacks (swallowed)
#
# FINE (detailed cache operations):
#   - Entry evictions due to size limit (includes key, policy, size)
#   - Successful background refresh operations
#   - Failed background refresh operations (with exception)
#
# ====================
# Example Use Cases
# ====================
#
# Production - minimal logging:
#   com.github.rudygunawan.kachi.Cache.level=WARNING
#
# Production - with operation tracking:
#   com.github.rudygunawan.kachi.Cache.level=FINE
#
# Development/Testing - full debugging:
#   com.github.rudygunawan.kachi.Cache.level=FINE
#
# Performance testing - no overhead:
#   com.github.rudygunawan.kachi.Cache.level=OFF

# ====================
# Integration with SLF4J
# ====================
#
# If your application uses SLF4J, you can bridge JUL to SLF4J:
#
# 1. Add dependency:
#    <dependency>
#      <groupId>org.slf4j</groupId>
#      <artifactId>jul-to-slf4j</artifactId>
#      <version>2.0.9</version>
#    </dependency>
#
# 2. Install bridge at application startup:
#    SLF4JBridgeHandler.removeHandlersForRootLogger();
#    SLF4JBridgeHandler.install();
#
# 3. Configure SLF4J logger:
#    <logger name="com.github.rudygunawan.kachi.Cache" level="WARN"/>
#
# Note: JUL-to-SLF4J bridge has ~20% performance overhead
